### 架构/对象/数据结构/模型/???设计

#### 基本设计



##### 计时&移动

- 我们把游戏建模成一个巨大的有限状态机：
  - **坐标总是整数**；以状态机为比喻，每一时刻的状态是离散且有限的
  - 所有物理状态的更新都发生在**整数的时间戳**上（以1秒或更短时间为单位，单位称为游戏刻/tick）；

- 角色的「动画更新」和「物理状态更新」是**<u>分离</u>**的；
  - 确保状态是有限离散，但是动画是连续的；
  - 比如说，加入玩家在t=0.5秒时按下右键后，游戏会立即播放移动动画，从0.5秒持续到1.5秒；但是状态更新会被buffer到1.0秒时再进行。并且，玩家在t=0.5–1.0秒内的其它状态更新都不会被受理。
  - 程序实现上，一个物体的动画系统应该是**自治**的；
    - 动画从物理系统读取信息，但不能反向写入
    - 物理系统只在最低限度上影响动画系统（并且尽可能通过一些预定的全局变量来干涉）：比如触发动画，强制结束动画？
- 疑难问题之：玩家A和机器B同时尝试走到格子X上。会发生什么？
  - 啥都不管的话，A和B就要重合了，这可不行；
  - 设置一个「下一刻物理信息」的buffer：对于已经决定发出的动作，直接存在buffer里。移动检测前在buffer里查找。也就是说运动中的物体会占2个格子。
  - 场景物体优先级总是比玩家控制物体高；场景物体和场景物体优先级随意。
    - 关卡设计中尽量避免场景物体和场景物体相撞

##### 静态对象vs动态对象

- 游戏环境内分为两类物体：**静态对象**和**动态对象**。
  - **静态对象**，在整个游戏时间轴内不会发生任何改变。我们不需要对其进行任何额外的信息储存。
  - **动态对象**，会在游戏时间轴内发生改变。我们需要储存信息以便时间回溯。
- 动态对象可以根据存在形式考虑为两类：**不可销毁对象**和**可销毁对象**。关卡会**维护一个所有对象的列表**。
  - **不可销毁对象**：物体始终存在于地图中，回溯时只需要覆盖数值就能回溯。
  - **可销毁对象**：物体可能会从地图中创建或消失。回溯时需要重新实例化或销毁。
  - 为了区分两类物体，我们必须给所有物体保存UUID信息。
    - 回溯时间时，首先从全局对象列表里检索相同UUID的对象，尝试覆盖信息；
      如果物体不存在，才考虑重新创建。



##### 坐标系统

- 坐标为整数对（int32/int8），储存(x, y, z, t)四个维度；
  - 按照惯例：XY平面坐标系，左上角是原点，横X纵Y (int32)；
  - 额外储存一个z轴已备不时之需(int8).
  - 还有个时间戳t (u16). 
- 移动：所有物理事件都要等候到整数秒才能触发。具体见前文「疑难问题之玩家A和机器B同时尝试走到格子X上」



##### 储存&读取快照

- 各种信息都由**对象自己保存**；场景只存储对象的索引（包含每个对象的list），不结构化存储额外的信息。
- 为了时间回溯，每个tick会保存数据，称为一次**快照**。

- 基于braid的思路，每分钟保存一个完整快照；每秒再保存一个delta快照。
- 所有快照注册在一个中心的manager单例中；实体能够reference自己的快照信息。
  - 数据：可能先存JSON Object，有优化需求再考虑空间优化。



##### 玩家控制

- 为了方便，不考虑手柄、键盘操纵的问题；在开发前期阶段，直接用鼠标左键来移动。
  - 左键点哪里，只要合法就移动到那里，否则什么也不发生

















